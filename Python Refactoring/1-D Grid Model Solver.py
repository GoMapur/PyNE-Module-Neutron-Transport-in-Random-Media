# TODO: 1. Documents codes
#       2. Add parameter docs
#       3. Unit testing
#       4. Class docs

# Codes for Nuclear Engineering Department @ Berkeley
# This is a summer project, translation and packaging past codes for 1-D
# Nutron transport simulations.
# Note this file is highly extensible so I suggest it could be used in future
# similar simulation designs, plz improve anything if you'd like, it would be
# my honor.
# Mingjian Lu, July 2016

class Model_1D_Numerical_Solver():
    def __init__(self, grid, discrete_direction_num = 2, total_point_num = -1, discretization_stepsize = -1,):
        self.n = total_point_num
        self.step_size = discretization_stepsize
        self.discrete_direction_num = discrete_direction_num
        self.grid = grid
        self.mesh = []

    def point_num(self):
        self.__check_n()
        return self.n

    def step_size(self):
        self.__check_s()
        return self.step_size

    def avg_step_size(self):
        self.__check_n()
        return float(self.len) / float(self.n)

    def __check_n(self):
        if self.n == -1:
            raise Exception("The grid needs to be generated since you are using a nontrivial grid.")

    def __check_s(self):
        if self.n == -1:
            raise Exception("This is a complex grid so there is no fixed step size, plz use avg_step_size method instead.")

    def check_init_state(self):
        return len(self.mesh) > 1

    def add_point(self, x):
        raise NotImplementedError

    def solve(self):
        raise NotImplementedError

class Model_1D_Stochastic_Finite_Step_Solver(Model_1D_Numerical_Solver):
    """ This is the finite step method solver for the stochastic model.
        Note theortically finite volumn method should perform better than this.
        1. The mesh generated by this class needs revision: TODO: 10/7/2016
    """
    def __init__(self, grid_model, base_point_num = -1, base_step_size = -1, discrete_direction_num = 2):
        assert((base_point_num == -1 or base_step_size == -1) and not (base_point_num == -1 and base_step_size == -1), "Please either specify base point number or base step size.")
        Model_1D_Numerical_Solver.__init__(self, grid = grid_model, discrete_direction_num = discrete_direction_num)
        if base_point_num != -1
            self.base_step_size = grid_model.len() / float(base_point_num)
            self.base_point_num = base_point_num
        else:
            self.base_step_size = base_step_size
            self.base_point_num = round(grid_model.len() / base_step_size)
        self.mesh += [0.0]
        # Start constructing the mesh, note we will add additional points on
        # interface and inside intercal if the basic points number and step
        # size is not enought to cover all the intervals
        for interval in grid_model:
            while self.mesh[-1] < interval.right():
                last_point = self.mesh[-1]
                next_base_point = self.base_step_size + last_point
                if next_base_point < interval.right():
                    # If adding a point does not cause exceeding the interface
                    self.mesh += [next_base_point]
                elif next_base_point >= interval.right():
                    if interval.left() == last_point:
                        self.mesh += [interval.mid_point(), interval.right()]
                    elseï¼š
                        self.mesh += [interval.right()]

    def solve(self):
        """ Build matrix and solve, more docs later
            Currently using three points to simulate. We shall try more points
            later
            # TODO: More flexibility that can use more points (say, 5?)
        """
        mesh_point_num = len(self.mesh)
        matrix_size = discrete_direction_num * mesh_point_num
        A = [[0 for _ in range(matrix_size)] for __ in range(matrix_size)]
        B = [0 for _ in range(matrix_size)]



    def add_point(self, x):
        for i in range(len(self.mesh)):
            if self.mesh[i] == x:
                return
            if self.mesh[i] < x and x < self.mesh[i+1]:
                self.mesh.insert(i+1, x)
                return
